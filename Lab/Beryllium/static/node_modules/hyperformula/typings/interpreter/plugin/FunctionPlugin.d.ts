/**
 * @license
 * Copyright (c) 2021 Handsoncode. All rights reserved.
 */
import { CellError, SimpleCellAddress } from '../../Cell';
import { Config } from '../../Config';
import { DependencyGraph } from '../../DependencyGraph';
import { SearchStrategy } from '../../Lookup/SearchStrategy';
import { Maybe } from '../../Maybe';
import { Ast, ProcedureAst } from '../../parser';
import { Serialization } from '../../Serialization';
import { complex } from '../ArithmeticHelper';
import { Interpreter } from '../Interpreter';
import { ExtendedNumber, InternalScalarValue, InterpreterValue, NumberType, RawNoErrorScalarValue, RawScalarValue } from '../InterpreterValue';
export interface ImplementedFunctions {
    [formulaId: string]: FunctionMetadata;
}
export interface FunctionArguments {
    parameters?: FunctionArgument[];
    /**
     * Used for functions with variable number of arguments -- tells how many last arguments can be repeated indefinitely.
     */
    repeatLastArgs?: number;
    /**
     * Ranges in arguments are inlined to (possibly multiple) scalar arguments.
     */
    expandRanges?: boolean;
    /**
     * Return number value is packed into this subtype.
     */
    returnNumberType?: NumberType;
}
export interface FunctionMetadata extends FunctionArguments {
    method: string;
    isVolatile?: boolean;
    isDependentOnSheetStructureChange?: boolean;
    doesNotNeedArgumentsToBeComputed?: boolean;
}
export interface FunctionPluginDefinition {
    new (interpreter: Interpreter): FunctionPlugin;
    implementedFunctions: ImplementedFunctions;
    aliases?: {
        [formulaId: string]: string;
    };
}
export declare enum ArgumentTypes {
    /**
     * String type.
     */
    STRING = "STRING",
    /**
     * Floating point type.
     */
    NUMBER = "NUMBER",
    /**
     * Boolean type.
     */
    BOOLEAN = "BOOLEAN",
    /**
     * Any non-range value.
     */
    SCALAR = "SCALAR",
    /**
     * Any non-range, no-error type.
     */
    NOERROR = "NOERROR",
    /**
     * Range type.
     */
    RANGE = "RANGE",
    /**
     * Integer type.
     */
    INTEGER = "INTEGER",
    /**
     * String representing complex number.
     */
    COMPLEX = "COMPLEX",
    /**
     * Range or scalar.
     */
    ANY = "ANY"
}
export interface FunctionArgument {
    argumentType: ArgumentTypes;
    /**
     * Argument should be passed with full type information.
     * (e.g. Date/DateTime/Time/Currency/Percentage for numbers)
     */
    passSubtype?: boolean;
    /**
     * If argument is missing, its value defaults to this.
     */
    defaultValue?: InternalScalarValue | RawScalarValue;
    /**
     * If argument is missing, and no defaultValue provided, undefined is supplied as a value, instead of throwing an error.
     * Logically equivalent to setting defaultValue = undefined.
     */
    optionalArg?: boolean;
    /**
     * Numeric argument needs to be greater-equal than this.
     */
    minValue?: number;
    /**
     * Numeric argument needs to be less-equal than this.
     */
    maxValue?: number;
    /**
     * Numeric argument needs to be less than this.
     */
    lessThan?: number;
    /**
     * Numeric argument needs to be greater than this.
     */
    greaterThan?: number;
}
export declare type PluginFunctionType = (ast: ProcedureAst, formulaAddress: SimpleCellAddress) => InternalScalarValue;
/**
 * Abstract class representing interpreter function plugin.
 * Plugin may contain multiple functions. Each function should be of type {@link PluginFunctionType} and needs to be
 * included in {@link implementedFunctions}
 */
export declare abstract class FunctionPlugin {
    /**
     * Dictionary containing functions implemented by specific plugin, along with function name translations.
     */
    static implementedFunctions: ImplementedFunctions;
    static aliases?: {
        [formulaId: string]: string;
    };
    protected readonly interpreter: Interpreter;
    protected readonly dependencyGraph: DependencyGraph;
    protected readonly columnSearch: SearchStrategy;
    protected readonly config: Config;
    protected readonly serialization: Serialization;
    constructor(interpreter: Interpreter);
    protected evaluateAst(ast: Ast, formulaAddress: SimpleCellAddress): InterpreterValue;
    protected listOfScalarValues(asts: Ast[], formulaAddress: SimpleCellAddress): [InternalScalarValue, boolean][];
    coerceScalarToNumberOrError: (arg: InternalScalarValue) => ExtendedNumber | CellError;
    coerceToType(arg: InterpreterValue, coercedType: FunctionArgument): Maybe<InterpreterValue | complex | RawNoErrorScalarValue>;
    protected runFunction: (args: Ast[], formulaAddress: SimpleCellAddress, functionDefinition: FunctionArguments, fn: (...arg: any) => InternalScalarValue) => InternalScalarValue;
    protected runMatrixFunction: (args: Ast[], formulaAddress: SimpleCellAddress, functionDefinition: FunctionArguments, fn: (...arg: any) => InterpreterValue) => InternalScalarValue;
    private runFunctionTemplate;
    protected runFunctionWithReferenceArgument: (args: Ast[], formulaAddress: SimpleCellAddress, argumentDefinitions: FunctionArguments, noArgCallback: () => InternalScalarValue | RawScalarValue, referenceCallback: (reference: SimpleCellAddress) => InternalScalarValue, nonReferenceCallback?: (...arg: any) => InternalScalarValue) => InternalScalarValue;
    protected metadata(name: string): FunctionMetadata;
    private returnNumberWrapper;
}

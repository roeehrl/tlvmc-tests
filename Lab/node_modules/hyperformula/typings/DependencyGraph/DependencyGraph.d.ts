/**
 * @license
 * Copyright (c) 2021 Handsoncode. All rights reserved.
 */
import { AbsoluteCellRange } from '../AbsoluteCellRange';
import { SimpleCellAddress } from '../Cell';
import { RawCellContent } from '../CellContentParser';
import { CellDependency } from '../CellDependency';
import { Config } from '../Config';
import { LazilyTransformingAstService } from '../LazilyTransformingAstService';
import { Maybe } from '../Maybe';
import { Ast } from '../parser';
import { ColumnsSpan, RowsSpan } from '../Span';
import { Statistics } from '../statistics';
import { NamedExpressions } from '../NamedExpressions';
import { CellVertex, MatrixVertex, ParsingErrorVertex, RangeVertex, Vertex } from './';
import { AddressMapping } from './AddressMapping/AddressMapping';
import { Graph, TopSortResult } from './Graph';
import { MatrixMapping } from './MatrixMapping';
import { RangeMapping } from './RangeMapping';
import { SheetMapping } from './SheetMapping';
import { RawAndParsedValue } from './ValueCellVertex';
import { FunctionRegistry } from '../interpreter/FunctionRegistry';
import { InternalScalarValue, InterpreterValue, RawScalarValue } from '../interpreter/InterpreterValue';
export declare class DependencyGraph {
    readonly addressMapping: AddressMapping;
    readonly rangeMapping: RangeMapping;
    readonly sheetMapping: SheetMapping;
    readonly matrixMapping: MatrixMapping;
    readonly stats: Statistics;
    readonly lazilyTransformingAstService: LazilyTransformingAstService;
    readonly functionRegistry: FunctionRegistry;
    readonly namedExpressions: NamedExpressions;
    static buildEmpty(lazilyTransformingAstService: LazilyTransformingAstService, config: Config, functionRegistry: FunctionRegistry, namedExpressions: NamedExpressions, stats: Statistics): DependencyGraph;
    readonly graph: Graph<Vertex>;
    constructor(addressMapping: AddressMapping, rangeMapping: RangeMapping, sheetMapping: SheetMapping, matrixMapping: MatrixMapping, stats: Statistics, lazilyTransformingAstService: LazilyTransformingAstService, functionRegistry: FunctionRegistry, namedExpressions: NamedExpressions);
    setFormulaToCell(address: SimpleCellAddress, ast: Ast, dependencies: CellDependency[], hasVolatileFunction: boolean, hasStructuralChangeFunction: boolean): void;
    setParsingErrorToCell(address: SimpleCellAddress, errorVertex: ParsingErrorVertex): void;
    setValueToCell(address: SimpleCellAddress, value: RawAndParsedValue): void;
    setCellEmpty(address: SimpleCellAddress): void;
    ensureThatVertexIsNonMatrixCellVertex(vertex: CellVertex | null): void;
    clearRecentlyChangedVertices(): void;
    verticesToRecompute(): Set<Vertex>;
    processCellDependencies(cellDependencies: CellDependency[], endVertex: Vertex): void;
    fetchNamedExpressionVertex(expressionName: string, sheetId: number): CellVertex;
    exchangeNode(addressFrom: SimpleCellAddress, addressTo: SimpleCellAddress): void;
    private correctInfiniteRangesDependenciesByRangeVertex;
    correctInfiniteRangesDependency(address: SimpleCellAddress): void;
    fetchCellOrCreateEmpty(address: SimpleCellAddress): CellVertex;
    removeRows(removedRows: RowsSpan): void;
    removeSheet(removedSheetId: number): void;
    clearSheet(sheetId: number): void;
    removeColumns(removedColumns: ColumnsSpan): void;
    addRows(addedRows: RowsSpan): void;
    addColumns(addedColumns: ColumnsSpan): void;
    ensureNoMatrixInRange(range: AbsoluteCellRange): void;
    moveCells(sourceRange: AbsoluteCellRange, toRight: number, toBottom: number, toSheet: number): void;
    disableNumericMatrices(): void;
    breakNumericMatricesInRange(range: AbsoluteCellRange): void;
    breakNumericMatrix(matrixVertex: MatrixVertex): void;
    setMatrixEmpty(matrixVertex: MatrixVertex): void;
    addVertex(address: SimpleCellAddress, vertex: CellVertex): void;
    addMatrixVertex(address: SimpleCellAddress, vertex: CellVertex): void;
    addNewMatrixVertex(matrixVertex: MatrixVertex): void;
    matrixFormulaNodes(): IterableIterator<MatrixVertex>;
    entriesFromRowsSpan(rowsSpan: RowsSpan): IterableIterator<[SimpleCellAddress, CellVertex]>;
    entriesFromColumnsSpan(columnsSpan: ColumnsSpan): IterableIterator<[SimpleCellAddress, CellVertex]>;
    existsVertex(address: SimpleCellAddress): boolean;
    fetchCell(address: SimpleCellAddress): CellVertex;
    getCell(address: SimpleCellAddress): CellVertex | null;
    getCellValue(address: SimpleCellAddress): InterpreterValue;
    getRawValue(address: SimpleCellAddress): RawCellContent;
    getScalarValue(address: SimpleCellAddress): InternalScalarValue;
    setVertexAddress(address: SimpleCellAddress, vertex: CellVertex): void;
    existsEdge(fromNode: Vertex, toNode: Vertex): boolean;
    getSheetId(sheetName: string): number;
    getSheetName(sheetId: number): string;
    getSheetHeight(sheet: number): number;
    getSheetWidth(sheet: number): number;
    getMatrix(range: AbsoluteCellRange): Maybe<MatrixVertex>;
    setMatrix(range: AbsoluteCellRange, vertex: MatrixVertex): void;
    getRange(start: SimpleCellAddress, end: SimpleCellAddress): Maybe<RangeVertex>;
    topSortWithScc(): TopSortResult<Vertex>;
    markAsVolatile(vertex: Vertex): void;
    markAsDependentOnStructureChange(vertex: Vertex): void;
    forceApplyPostponedTransformations(): void;
    volatileVertices(): Set<Vertex>;
    destroy(): void;
    verticesFromRange(range: AbsoluteCellRange): IterableIterator<CellVertex>;
    rawValuesFromRange(range: AbsoluteCellRange): IterableIterator<[RawScalarValue, SimpleCellAddress]>;
    entriesFromRange(range: AbsoluteCellRange): IterableIterator<[SimpleCellAddress, CellVertex | null]>;
    exchangeGraphNode(oldNode: Vertex, newNode: Vertex): void;
    exchangeOrAddGraphNode(oldNode: Vertex | null, newNode: Vertex): void;
    dependencyQueryAddresses: (vertex: Vertex) => Maybe<(SimpleCellAddress | AbsoluteCellRange)[]>;
    dependencyQueryVertices: (vertex: Vertex) => Maybe<Vertex[]>;
    computeListOfValuesInRange(range: AbsoluteCellRange): InternalScalarValue[];
    private rangeDependencyQuery;
    private formulaDependencyQuery;
    private addStructuralNodesToChangeSet;
    private fixRangesWhenAddingRows;
    private addAllFromRange;
    private fixRangesWhenAddingColumns;
    private setAddressMappingForMatrixVertex;
    private truncateMatricesAfterRemovingRows;
    private truncateRanges;
    private truncateMatricesAfterRemovingColumns;
    private expandMatricesAfterAddingRows;
    private expandMatricesAfterAddingColumns;
    private removeVertex;
    private mergeRangeVertices;
    private removeVertexAndCleanupDependencies;
    getAdjacentNodesAddresses(inputVertex: Vertex): (AbsoluteCellRange | SimpleCellAddress)[];
}

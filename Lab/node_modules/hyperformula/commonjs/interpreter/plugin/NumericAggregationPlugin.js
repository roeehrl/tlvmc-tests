"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

require("core-js/modules/es.object.get-prototype-of.js");

require("core-js/modules/es.reflect.construct.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.function.name.js");

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.symbol.iterator.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/web.dom-collections.iterator.js");

exports.__esModule = true;
exports.NumericAggregationPlugin = void 0;

require("core-js/modules/es.number.is-finite.js");

require("core-js/modules/es.number.constructor.js");

require("core-js/modules/es.array.reduce.js");

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.array.filter.js");

require("core-js/modules/es.array.map.js");

require("core-js/modules/es.array.from.js");

require("core-js/modules/es.string.iterator.js");

var _AbsoluteCellRange = require("../../AbsoluteCellRange");

var _Cell = require("../../Cell");

var _errorMessage = require("../../error-message");

var _parser = require("../../parser");

var _ArithmeticHelper = require("../ArithmeticHelper");

var _InterpreterValue = require("../InterpreterValue");

var _SimpleRangeValue = require("../SimpleRangeValue");

var _FunctionPlugin2 = require("./FunctionPlugin");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function identityMap(arg) {
  return arg;
}

function zeroForInfinite(value) {
  if ((0, _InterpreterValue.isExtendedNumber)(value) && !Number.isFinite((0, _InterpreterValue.getRawValue)(value))) {
    return 0;
  } else {
    return value;
  }
}

var MomentsAggregate = /*#__PURE__*/function () {
  function MomentsAggregate(sumsq, sum, count) {
    _classCallCheck(this, MomentsAggregate);

    this.sumsq = sumsq;
    this.sum = sum;
    this.count = count;
  }

  _createClass(MomentsAggregate, [{
    key: "compose",
    value: function compose(other) {
      return new MomentsAggregate(this.sumsq + other.sumsq, this.sum + other.sum, this.count + other.count);
    }
  }, {
    key: "averageValue",
    value: function averageValue() {
      if (this.count > 0) {
        return this.sum / this.count;
      } else {
        return undefined;
      }
    }
  }, {
    key: "varSValue",
    value: function varSValue() {
      if (this.count > 1) {
        return (this.sumsq - this.sum * this.sum / this.count) / (this.count - 1);
      } else {
        return undefined;
      }
    }
  }, {
    key: "varPValue",
    value: function varPValue() {
      if (this.count > 0) {
        return (this.sumsq - this.sum * this.sum / this.count) / this.count;
      } else {
        return undefined;
      }
    }
  }], [{
    key: "single",
    value: function single(arg) {
      return new MomentsAggregate(arg * arg, arg, 1);
    }
  }]);

  return MomentsAggregate;
}();

MomentsAggregate.empty = new MomentsAggregate(0, 0, 0);

var NumericAggregationPlugin = /*#__PURE__*/function (_FunctionPlugin) {
  _inherits(NumericAggregationPlugin, _FunctionPlugin);

  var _super = _createSuper(NumericAggregationPlugin);

  function NumericAggregationPlugin() {
    var _this;

    _classCallCheck(this, NumericAggregationPlugin);

    _this = _super.apply(this, arguments);

    _this.addWithEpsilonRaw = function (left, right) {
      return _this.interpreter.arithmeticHelper.addWithEpsilonRaw(left, right);
    };

    return _this;
  }
  /**
   * Corresponds to SUM(Number1, Number2, ...).
   *
   * Returns a sum of given numbers.
   *
   * @param ast
   * @param formulaAddress
   */


  _createClass(NumericAggregationPlugin, [{
    key: "sum",
    value: function sum(ast, formulaAddress) {
      return this.doSum(ast.args, formulaAddress);
    }
  }, {
    key: "sumsq",
    value: function sumsq(ast, formulaAddress) {
      return this.reduce(ast.args, formulaAddress, 0, 'SUMSQ', this.addWithEpsilonRaw, function (arg) {
        return Math.pow((0, _InterpreterValue.getRawValue)(arg), 2);
      }, strictlyNumbers);
    }
    /**
     * Corresponds to MAX(Number1, Number2, ...).
     *
     * Returns a max of given numbers.
     *
     * @param ast
     * @param formulaAddress
     */

  }, {
    key: "max",
    value: function max(ast, formulaAddress) {
      return this.doMax(ast.args, formulaAddress);
    }
  }, {
    key: "maxa",
    value: function maxa(ast, formulaAddress) {
      var value = this.reduce(ast.args, formulaAddress, Number.NEGATIVE_INFINITY, 'MAXA', function (left, right) {
        return Math.max(left, right);
      }, _InterpreterValue.getRawValue, numbersBooleans);
      return zeroForInfinite(value);
    }
    /**
     * Corresponds to MIN(Number1, Number2, ...).
     *
     * Returns a min of given numbers.
     *
     * @param ast
     * @param formulaAddress
     */

  }, {
    key: "min",
    value: function min(ast, formulaAddress) {
      return this.doMin(ast.args, formulaAddress);
    }
  }, {
    key: "mina",
    value: function mina(ast, formulaAddress) {
      var value = this.reduce(ast.args, formulaAddress, Number.POSITIVE_INFINITY, 'MINA', function (left, right) {
        return Math.min(left, right);
      }, _InterpreterValue.getRawValue, numbersBooleans);
      return zeroForInfinite(value);
    }
  }, {
    key: "count",
    value: function count(ast, formulaAddress) {
      return this.doCount(ast.args, formulaAddress);
    }
  }, {
    key: "counta",
    value: function counta(ast, formulaAddress) {
      return this.doCounta(ast.args, formulaAddress);
    }
  }, {
    key: "average",
    value: function average(ast, formulaAddress) {
      return this.doAverage(ast.args, formulaAddress);
    }
  }, {
    key: "averagea",
    value: function averagea(ast, formulaAddress) {
      var _a;

      var result = this.reduce(ast.args, formulaAddress, MomentsAggregate.empty, '_AGGREGATE_A', function (left, right) {
        return left.compose(right);
      }, function (arg) {
        return MomentsAggregate.single((0, _InterpreterValue.getRawValue)(arg));
      }, numbersBooleans);

      if (result instanceof _Cell.CellError) {
        return result;
      } else {
        return (_a = result.averageValue()) !== null && _a !== void 0 ? _a : new _Cell.CellError(_Cell.ErrorType.DIV_BY_ZERO);
      }
    }
  }, {
    key: "vars",
    value: function vars(ast, formulaAddress) {
      return this.doVarS(ast.args, formulaAddress);
    }
  }, {
    key: "varp",
    value: function varp(ast, formulaAddress) {
      return this.doVarP(ast.args, formulaAddress);
    }
  }, {
    key: "vara",
    value: function vara(ast, formulaAddress) {
      var _a;

      var result = this.reduceAggregateA(ast.args, formulaAddress);

      if (result instanceof _Cell.CellError) {
        return result;
      } else {
        return (_a = result.varSValue()) !== null && _a !== void 0 ? _a : new _Cell.CellError(_Cell.ErrorType.DIV_BY_ZERO);
      }
    }
  }, {
    key: "varpa",
    value: function varpa(ast, formulaAddress) {
      var _a;

      var result = this.reduceAggregateA(ast.args, formulaAddress);

      if (result instanceof _Cell.CellError) {
        return result;
      } else {
        return (_a = result.varPValue()) !== null && _a !== void 0 ? _a : new _Cell.CellError(_Cell.ErrorType.DIV_BY_ZERO);
      }
    }
  }, {
    key: "stdevs",
    value: function stdevs(ast, formulaAddress) {
      return this.doStdevS(ast.args, formulaAddress);
    }
  }, {
    key: "stdevp",
    value: function stdevp(ast, formulaAddress) {
      return this.doStdevP(ast.args, formulaAddress);
    }
  }, {
    key: "stdeva",
    value: function stdeva(ast, formulaAddress) {
      var result = this.reduceAggregateA(ast.args, formulaAddress);

      if (result instanceof _Cell.CellError) {
        return result;
      } else {
        var val = result.varSValue();
        return val === undefined ? new _Cell.CellError(_Cell.ErrorType.DIV_BY_ZERO) : Math.sqrt(val);
      }
    }
  }, {
    key: "stdevpa",
    value: function stdevpa(ast, formulaAddress) {
      var result = this.reduceAggregateA(ast.args, formulaAddress);

      if (result instanceof _Cell.CellError) {
        return result;
      } else {
        var val = result.varPValue();
        return val === undefined ? new _Cell.CellError(_Cell.ErrorType.DIV_BY_ZERO) : Math.sqrt(val);
      }
    }
  }, {
    key: "product",
    value: function product(ast, formulaAddress) {
      return this.doProduct(ast.args, formulaAddress);
    }
  }, {
    key: "subtotal",
    value: function subtotal(ast, formulaAddress) {
      if (ast.args.length < 1) {
        return new _Cell.CellError(_Cell.ErrorType.NA, _errorMessage.ErrorMessage.WrongArgNumber);
      }

      var functionType = this.coerceToType(this.evaluateAst(ast.args[0], formulaAddress), {
        argumentType: _FunctionPlugin2.ArgumentTypes.NUMBER
      });
      var args = ast.args.slice(1);

      switch (functionType) {
        case 1:
        case 101:
          return this.doAverage(args, formulaAddress);

        case 2:
        case 102:
          return this.doCount(args, formulaAddress);

        case 3:
        case 103:
          return this.doCounta(args, formulaAddress);

        case 4:
        case 104:
          return this.doMax(args, formulaAddress);

        case 5:
        case 105:
          return this.doMin(args, formulaAddress);

        case 6:
        case 106:
          return this.doProduct(args, formulaAddress);

        case 7:
        case 107:
          return this.doStdevS(args, formulaAddress);

        case 8:
        case 108:
          return this.doStdevP(args, formulaAddress);

        case 9:
        case 109:
          return this.doSum(args, formulaAddress);

        case 10:
        case 110:
          return this.doVarS(args, formulaAddress);

        case 11:
        case 111:
          return this.doVarP(args, formulaAddress);

        default:
          return new _Cell.CellError(_Cell.ErrorType.VALUE, _errorMessage.ErrorMessage.BadMode);
      }
    }
  }, {
    key: "reduceAggregate",
    value: function reduceAggregate(args, formulaAddress) {
      return this.reduce(args, formulaAddress, MomentsAggregate.empty, '_AGGREGATE', function (left, right) {
        return left.compose(right);
      }, function (arg) {
        return MomentsAggregate.single((0, _InterpreterValue.getRawValue)(arg));
      }, strictlyNumbers);
    }
  }, {
    key: "reduceAggregateA",
    value: function reduceAggregateA(args, formulaAddress) {
      return this.reduce(args, formulaAddress, MomentsAggregate.empty, '_AGGREGATE_A', function (left, right) {
        return left.compose(right);
      }, function (arg) {
        return MomentsAggregate.single((0, _InterpreterValue.getRawValue)(arg));
      }, numbersBooleans);
    }
  }, {
    key: "doAverage",
    value: function doAverage(args, formulaAddress) {
      var _a;

      var result = this.reduceAggregate(args, formulaAddress);

      if (result instanceof _Cell.CellError) {
        return result;
      } else {
        return (_a = result.averageValue()) !== null && _a !== void 0 ? _a : new _Cell.CellError(_Cell.ErrorType.DIV_BY_ZERO);
      }
    }
  }, {
    key: "doVarS",
    value: function doVarS(args, formulaAddress) {
      var _a;

      var result = this.reduceAggregate(args, formulaAddress);

      if (result instanceof _Cell.CellError) {
        return result;
      } else {
        return (_a = result.varSValue()) !== null && _a !== void 0 ? _a : new _Cell.CellError(_Cell.ErrorType.DIV_BY_ZERO);
      }
    }
  }, {
    key: "doVarP",
    value: function doVarP(args, formulaAddress) {
      var _a;

      var result = this.reduceAggregate(args, formulaAddress);

      if (result instanceof _Cell.CellError) {
        return result;
      } else {
        return (_a = result.varPValue()) !== null && _a !== void 0 ? _a : new _Cell.CellError(_Cell.ErrorType.DIV_BY_ZERO);
      }
    }
  }, {
    key: "doStdevS",
    value: function doStdevS(args, formulaAddress) {
      var result = this.reduceAggregate(args, formulaAddress);

      if (result instanceof _Cell.CellError) {
        return result;
      } else {
        var val = result.varSValue();
        return val === undefined ? new _Cell.CellError(_Cell.ErrorType.DIV_BY_ZERO) : Math.sqrt(val);
      }
    }
  }, {
    key: "doStdevP",
    value: function doStdevP(args, formulaAddress) {
      var result = this.reduceAggregate(args, formulaAddress);

      if (result instanceof _Cell.CellError) {
        return result;
      } else {
        var val = result.varPValue();
        return val === undefined ? new _Cell.CellError(_Cell.ErrorType.DIV_BY_ZERO) : Math.sqrt(val);
      }
    }
  }, {
    key: "doCount",
    value: function doCount(args, formulaAddress) {
      return this.reduce(args, formulaAddress, 0, 'COUNT', function (left, right) {
        return left + right;
      }, _InterpreterValue.getRawValue, function (arg) {
        return (0, _InterpreterValue.isExtendedNumber)(arg) ? 1 : 0;
      });
    }
  }, {
    key: "doCounta",
    value: function doCounta(args, formulaAddress) {
      return this.reduce(args, formulaAddress, 0, 'COUNTA', function (left, right) {
        return left + right;
      }, _InterpreterValue.getRawValue, function (arg) {
        return arg === _InterpreterValue.EmptyValue ? 0 : 1;
      });
    }
  }, {
    key: "doMax",
    value: function doMax(args, formulaAddress) {
      var value = this.reduce(args, formulaAddress, Number.NEGATIVE_INFINITY, 'MAX', function (left, right) {
        return Math.max(left, right);
      }, _InterpreterValue.getRawValue, strictlyNumbers);
      return zeroForInfinite(value);
    }
  }, {
    key: "doMin",
    value: function doMin(args, formulaAddress) {
      var value = this.reduce(args, formulaAddress, Number.POSITIVE_INFINITY, 'MAX', function (left, right) {
        return Math.min(left, right);
      }, _InterpreterValue.getRawValue, strictlyNumbers);
      return zeroForInfinite(value);
    }
  }, {
    key: "doSum",
    value: function doSum(args, formulaAddress) {
      return this.reduce(args, formulaAddress, 0, 'SUM', this.addWithEpsilonRaw, _InterpreterValue.getRawValue, strictlyNumbers);
    }
  }, {
    key: "doProduct",
    value: function doProduct(args, formulaAddress) {
      return this.reduce(args, formulaAddress, 1, 'PRODUCT', function (left, right) {
        return left * right;
      }, _InterpreterValue.getRawValue, strictlyNumbers);
    }
    /**
     * Reduces procedure arguments with given reducing function
     *
     * @param ast - cell range ast
     * @param formulaAddress - address of the cell in which formula is located
     * @param initialAccValue - initial accumulator value for reducing function
     * @param functionName - function name to use as cache key
     * @param reducingFunction - reducing function
     * @param mapFunction
     * @param coerceFunction
     * */

  }, {
    key: "reduce",
    value: function reduce(args, formulaAddress, initialAccValue, functionName, reducingFunction, mapFunction, coercionFunction) {
      var _this2 = this;

      if (args.length < 1) {
        return new _Cell.CellError(_Cell.ErrorType.NA, _errorMessage.ErrorMessage.WrongArgNumber);
      }

      return args.reduce(function (acc, arg) {
        if (acc instanceof _Cell.CellError) {
          return acc;
        }

        if (arg.type === _parser.AstNodeType.CELL_RANGE || arg.type === _parser.AstNodeType.COLUMN_RANGE || arg.type === _parser.AstNodeType.ROW_RANGE) {
          return _this2.evaluateRange(arg, formulaAddress, acc, functionName, reducingFunction, mapFunction, coercionFunction);
        }

        var value;
        value = _this2.evaluateAst(arg, formulaAddress);

        if (value instanceof _SimpleRangeValue.SimpleRangeValue) {
          var coercedRangeValues = Array.from(value.valuesFromTopLeftCorner()).map(coercionFunction).filter(function (arg) {
            return arg !== undefined;
          });
          return coercedRangeValues.map(function (arg) {
            if (arg instanceof _Cell.CellError) {
              return arg;
            } else {
              return mapFunction(arg);
            }
          }).reduce(function (left, right) {
            if (left instanceof _Cell.CellError) {
              return left;
            } else if (right instanceof _Cell.CellError) {
              return right;
            } else {
              return reducingFunction(left, right);
            }
          }, acc);
        } else if (arg.type === _parser.AstNodeType.CELL_REFERENCE) {
          value = coercionFunction(value);

          if (value === undefined) {
            return acc;
          }
        } else {
          value = _this2.coerceScalarToNumberOrError(value);
          value = coercionFunction(value);

          if (value === undefined) {
            return acc;
          }
        }

        if (value instanceof _Cell.CellError) {
          return value;
        }

        return reducingFunction(acc, mapFunction(value));
      }, initialAccValue);
    }
    /**
     * Performs range operation on given range
     *
     * @param ast - cell range ast
     * @param formulaAddress - address of the cell in which formula is located
     * @param initialAccValue - initial accumulator value for reducing function
     * @param functionName - function name to use as cache key
     * @param reducingFunction - reducing function
     */

  }, {
    key: "evaluateRange",
    value: function evaluateRange(ast, formulaAddress, initialAccValue, functionName, reducingFunction, mapFunction, coercionFunction) {
      var range;

      try {
        range = _AbsoluteCellRange.AbsoluteCellRange.fromAst(ast, formulaAddress);
      } catch (err) {
        if (err.message === _AbsoluteCellRange.DIFFERENT_SHEETS_ERROR) {
          return new _Cell.CellError(_Cell.ErrorType.REF, _errorMessage.ErrorMessage.RangeManySheets);
        } else {
          throw err;
        }
      }

      var rangeStart = range.start;
      var rangeEnd = range.end;
      var rangeVertex = this.dependencyGraph.getRange(rangeStart, rangeEnd);

      if (!rangeVertex) {
        throw new Error('Range does not exists in graph');
      }

      var value = rangeVertex.getFunctionValue(functionName);

      if (!value) {
        var rangeValues = this.getRangeValues(functionName, range, mapFunction, coercionFunction);
        value = rangeValues.reduce(function (arg1, arg2) {
          if (arg1 instanceof _Cell.CellError) {
            return arg1;
          } else if (arg2 instanceof _Cell.CellError) {
            return arg2;
          } else {
            return reducingFunction(arg1, arg2);
          }
        }, initialAccValue);
        rangeVertex.setFunctionValue(functionName, value);
      }

      return value;
    }
    /**
     * Returns list of values for given range and function name
     *
     * If range is dependent on smaller range, list will contain value of smaller range for this function
     * and values of cells that are not present in smaller range
     *
     * @param functionName - function name (e.g. SUM)
     * @param range - cell range
     */

  }, {
    key: "getRangeValues",
    value: function getRangeValues(functionName, range, mapFunction, coercionFunction) {
      var rangeResult = [];

      var _this$dependencyGraph = this.dependencyGraph.rangeMapping.findSmallerRange(range),
          smallerRangeVertex = _this$dependencyGraph.smallerRangeVertex,
          restRange = _this$dependencyGraph.restRange;

      var currentRangeVertex = this.dependencyGraph.getRange(range.start, range.end);
      var actualRange;

      if (smallerRangeVertex && this.dependencyGraph.existsEdge(smallerRangeVertex, currentRangeVertex)) {
        var cachedValue = smallerRangeVertex.getFunctionValue(functionName);

        if (cachedValue) {
          rangeResult.push(cachedValue);
        } else {
          var _iterator = _createForOfIteratorHelper(smallerRangeVertex.range.addresses(this.dependencyGraph)),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var cellFromRange = _step.value;
              var val = coercionFunction(this.dependencyGraph.getScalarValue(cellFromRange));

              if (val instanceof _Cell.CellError) {
                rangeResult.push(val);
              } else if (val !== undefined) {
                rangeResult.push(mapFunction(val));
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }

        actualRange = restRange;
      } else {
        actualRange = range;
      }

      var _iterator2 = _createForOfIteratorHelper(actualRange.addresses(this.dependencyGraph)),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _cellFromRange = _step2.value;

          var _val = coercionFunction(this.dependencyGraph.getScalarValue(_cellFromRange));

          if (_val instanceof _Cell.CellError) {
            rangeResult.push(_val);
          } else if (_val !== undefined) {
            rangeResult.push(mapFunction(_val));
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return rangeResult;
    }
  }]);

  return NumericAggregationPlugin;
}(_FunctionPlugin2.FunctionPlugin);

exports.NumericAggregationPlugin = NumericAggregationPlugin;
NumericAggregationPlugin.implementedFunctions = {
  'SUM': {
    method: 'sum'
  },
  'SUMSQ': {
    method: 'sumsq'
  },
  'MAX': {
    method: 'max'
  },
  'MIN': {
    method: 'min'
  },
  'MAXA': {
    method: 'maxa'
  },
  'MINA': {
    method: 'mina'
  },
  'COUNT': {
    method: 'count'
  },
  'COUNTA': {
    method: 'counta'
  },
  'AVERAGE': {
    method: 'average'
  },
  'AVERAGEA': {
    method: 'averagea'
  },
  'PRODUCT': {
    method: 'product'
  },
  'VAR.S': {
    method: 'vars'
  },
  'VAR.P': {
    method: 'varp'
  },
  'VARA': {
    method: 'vara'
  },
  'VARPA': {
    method: 'varpa'
  },
  'STDEV.S': {
    method: 'stdevs'
  },
  'STDEV.P': {
    method: 'stdevp'
  },
  'STDEVA': {
    method: 'stdeva'
  },
  'STDEVPA': {
    method: 'stdevpa'
  },
  'SUBTOTAL': {
    method: 'subtotal'
  }
};
NumericAggregationPlugin.aliases = {
  VAR: 'VAR.S',
  VARP: 'VAR.P',
  STDEV: 'STDEV.S',
  STDEVP: 'STDEV.P',
  VARS: 'VAR.S',
  STDEVS: 'STDEV.S'
};

function strictlyNumbers(arg) {
  if ((0, _InterpreterValue.isExtendedNumber)(arg) || arg instanceof _Cell.CellError) {
    return arg;
  } else {
    return undefined;
  }
}

function numbersBooleans(arg) {
  if (typeof arg === 'boolean') {
    return (0, _ArithmeticHelper.coerceBooleanToNumber)(arg);
  } else if ((0, _InterpreterValue.isExtendedNumber)(arg) || arg instanceof _Cell.CellError) {
    return arg;
  } else if (typeof arg === 'string') {
    return 0;
  } else {
    return undefined;
  }
}
"use strict";

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.symbol.iterator.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/web.dom-collections.iterator.js");

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.function.name.js");

require("core-js/modules/es.array.from.js");

exports.__esModule = true;
exports.Interpreter = void 0;

require("core-js/modules/es.array.concat.js");

var _AbsoluteCellRange = require("../AbsoluteCellRange");

var _Cell = require("../Cell");

var _errorMessage = require("../error-message");

var _Matrix = require("../Matrix");

var _Ast = require("../parser/Ast");

var _ArithmeticHelper = require("./ArithmeticHelper");

var _Criterion = require("./Criterion");

var _FunctionRegistry = require("./FunctionRegistry");

var _InterpreterValue = require("./InterpreterValue");

var _SimpleRangeValue = require("./SimpleRangeValue");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Interpreter = /*#__PURE__*/function () {
  function Interpreter(dependencyGraph, columnSearch, config, stats, dateHelper, numberLiteralsHelper, functionRegistry, namedExpressions, serialization) {
    _classCallCheck(this, Interpreter);

    this.dependencyGraph = dependencyGraph;
    this.columnSearch = columnSearch;
    this.config = config;
    this.stats = stats;
    this.dateHelper = dateHelper;
    this.numberLiteralsHelper = numberLiteralsHelper;
    this.functionRegistry = functionRegistry;
    this.namedExpressions = namedExpressions;
    this.serialization = serialization;
    this.functionRegistry.initializePlugins(this);
    this.arithmeticHelper = new _ArithmeticHelper.ArithmeticHelper(config, dateHelper, numberLiteralsHelper);
    this.criterionBuilder = new _Criterion.CriterionBuilder(config);
  }

  _createClass(Interpreter, [{
    key: "evaluateAst",
    value: function evaluateAst(ast, formulaAddress) {
      var val = this.evaluateAstWithoutPostprocessing(ast, formulaAddress);

      if ((0, _InterpreterValue.isExtendedNumber)(val)) {
        if ((0, _ArithmeticHelper.isNumberOverflow)((0, _InterpreterValue.getRawValue)(val))) {
          return new _Cell.CellError(_Cell.ErrorType.NUM, _errorMessage.ErrorMessage.NaN);
        } else {
          val = (0, _InterpreterValue.cloneNumber)(val, (0, _ArithmeticHelper.fixNegativeZero)((0, _InterpreterValue.getRawValue)(val)));
        }
      }

      return wrapperForAddress(val, formulaAddress);
    }
    /**
     * Calculates cell value from formula abstract syntax tree
     *
     * @param formula - abstract syntax tree of formula
     * @param formulaAddress - address of the cell in which formula is located
     */

  }, {
    key: "evaluateAstWithoutPostprocessing",
    value: function evaluateAstWithoutPostprocessing(ast, formulaAddress) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;

      switch (ast.type) {
        case _Ast.AstNodeType.EMPTY:
          {
            return _InterpreterValue.EmptyValue;
          }

        case _Ast.AstNodeType.CELL_REFERENCE:
          {
            var address = ast.reference.toSimpleCellAddress(formulaAddress);

            if ((0, _Cell.invalidSimpleCellAddress)(address)) {
              return new _Cell.CellError(_Cell.ErrorType.REF, _errorMessage.ErrorMessage.BadRef);
            }

            return this.dependencyGraph.getCellValue(address);
          }

        case _Ast.AstNodeType.NUMBER:
        case _Ast.AstNodeType.STRING:
          {
            return ast.value;
          }

        case _Ast.AstNodeType.CONCATENATE_OP:
          {
            var leftResult = this.evaluateAst(ast.left, formulaAddress);
            var rightResult = this.evaluateAst(ast.right, formulaAddress);
            return (_a = passErrors(leftResult, rightResult)) !== null && _a !== void 0 ? _a : wrapperBinary(this.arithmeticHelper.concat, (0, _ArithmeticHelper.coerceScalarToString)(leftResult), (0, _ArithmeticHelper.coerceScalarToString)(rightResult));
          }

        case _Ast.AstNodeType.EQUALS_OP:
          {
            var _leftResult = this.evaluateAst(ast.left, formulaAddress);

            var _rightResult = this.evaluateAst(ast.right, formulaAddress);

            return (_b = passErrors(_leftResult, _rightResult)) !== null && _b !== void 0 ? _b : this.arithmeticHelper.eq(_leftResult, _rightResult);
          }

        case _Ast.AstNodeType.NOT_EQUAL_OP:
          {
            var _leftResult2 = this.evaluateAst(ast.left, formulaAddress);

            var _rightResult2 = this.evaluateAst(ast.right, formulaAddress);

            return (_c = passErrors(_leftResult2, _rightResult2)) !== null && _c !== void 0 ? _c : this.arithmeticHelper.neq(_leftResult2, _rightResult2);
          }

        case _Ast.AstNodeType.GREATER_THAN_OP:
          {
            var _leftResult3 = this.evaluateAst(ast.left, formulaAddress);

            var _rightResult3 = this.evaluateAst(ast.right, formulaAddress);

            return (_d = passErrors(_leftResult3, _rightResult3)) !== null && _d !== void 0 ? _d : this.arithmeticHelper.gt(_leftResult3, _rightResult3);
          }

        case _Ast.AstNodeType.LESS_THAN_OP:
          {
            var _leftResult4 = this.evaluateAst(ast.left, formulaAddress);

            var _rightResult4 = this.evaluateAst(ast.right, formulaAddress);

            return (_e = passErrors(_leftResult4, _rightResult4)) !== null && _e !== void 0 ? _e : this.arithmeticHelper.lt(_leftResult4, _rightResult4);
          }

        case _Ast.AstNodeType.GREATER_THAN_OR_EQUAL_OP:
          {
            var _leftResult5 = this.evaluateAst(ast.left, formulaAddress);

            var _rightResult5 = this.evaluateAst(ast.right, formulaAddress);

            return (_f = passErrors(_leftResult5, _rightResult5)) !== null && _f !== void 0 ? _f : this.arithmeticHelper.geq(_leftResult5, _rightResult5);
          }

        case _Ast.AstNodeType.LESS_THAN_OR_EQUAL_OP:
          {
            var _leftResult6 = this.evaluateAst(ast.left, formulaAddress);

            var _rightResult6 = this.evaluateAst(ast.right, formulaAddress);

            return (_g = passErrors(_leftResult6, _rightResult6)) !== null && _g !== void 0 ? _g : this.arithmeticHelper.leq(_leftResult6, _rightResult6);
          }

        case _Ast.AstNodeType.PLUS_OP:
          {
            var _leftResult7 = this.evaluateAst(ast.left, formulaAddress);

            var _rightResult7 = this.evaluateAst(ast.right, formulaAddress);

            return (_h = passErrors(_leftResult7, _rightResult7)) !== null && _h !== void 0 ? _h : wrapperBinary(this.arithmeticHelper.addWithEpsilon, this.arithmeticHelper.coerceScalarToNumberOrError(_leftResult7), this.arithmeticHelper.coerceScalarToNumberOrError(_rightResult7));
          }

        case _Ast.AstNodeType.MINUS_OP:
          {
            var _leftResult8 = this.evaluateAst(ast.left, formulaAddress);

            var _rightResult8 = this.evaluateAst(ast.right, formulaAddress);

            return (_j = passErrors(_leftResult8, _rightResult8)) !== null && _j !== void 0 ? _j : wrapperBinary(this.arithmeticHelper.subtract, this.arithmeticHelper.coerceScalarToNumberOrError(_leftResult8), this.arithmeticHelper.coerceScalarToNumberOrError(_rightResult8));
          }

        case _Ast.AstNodeType.TIMES_OP:
          {
            var _leftResult9 = this.evaluateAst(ast.left, formulaAddress);

            var _rightResult9 = this.evaluateAst(ast.right, formulaAddress);

            return (_k = passErrors(_leftResult9, _rightResult9)) !== null && _k !== void 0 ? _k : wrapperBinary(this.arithmeticHelper.multiply, this.arithmeticHelper.coerceScalarToNumberOrError(_leftResult9), this.arithmeticHelper.coerceScalarToNumberOrError(_rightResult9));
          }

        case _Ast.AstNodeType.POWER_OP:
          {
            var _leftResult10 = this.evaluateAst(ast.left, formulaAddress);

            var _rightResult10 = this.evaluateAst(ast.right, formulaAddress);

            return (_l = passErrors(_leftResult10, _rightResult10)) !== null && _l !== void 0 ? _l : wrapperBinary(this.arithmeticHelper.pow, this.arithmeticHelper.coerceScalarToNumberOrError(_leftResult10), this.arithmeticHelper.coerceScalarToNumberOrError(_rightResult10));
          }

        case _Ast.AstNodeType.DIV_OP:
          {
            var _leftResult11 = this.evaluateAst(ast.left, formulaAddress);

            var _rightResult11 = this.evaluateAst(ast.right, formulaAddress);

            return (_m = passErrors(_leftResult11, _rightResult11)) !== null && _m !== void 0 ? _m : wrapperBinary(this.arithmeticHelper.divide, this.arithmeticHelper.coerceScalarToNumberOrError(_leftResult11), this.arithmeticHelper.coerceScalarToNumberOrError(_rightResult11));
          }

        case _Ast.AstNodeType.PLUS_UNARY_OP:
          {
            var result = this.evaluateAst(ast.value, formulaAddress);

            if (result instanceof _SimpleRangeValue.SimpleRangeValue) {
              return new _Cell.CellError(_Cell.ErrorType.VALUE, _errorMessage.ErrorMessage.ScalarExpected);
            } else if ((0, _InterpreterValue.isExtendedNumber)(result)) {
              return this.arithmeticHelper.unaryPlus(result);
            } else {
              return result;
            }
          }

        case _Ast.AstNodeType.MINUS_UNARY_OP:
          {
            var _result = this.evaluateAst(ast.value, formulaAddress);

            if (_result instanceof _SimpleRangeValue.SimpleRangeValue) {
              return new _Cell.CellError(_Cell.ErrorType.VALUE, _errorMessage.ErrorMessage.ScalarExpected);
            } else {
              return wrapperUnary(this.arithmeticHelper.unaryMinus, this.arithmeticHelper.coerceScalarToNumberOrError(_result));
            }
          }

        case _Ast.AstNodeType.PERCENT_OP:
          {
            var _result2 = this.evaluateAst(ast.value, formulaAddress);

            if (_result2 instanceof _SimpleRangeValue.SimpleRangeValue) {
              return new _Cell.CellError(_Cell.ErrorType.VALUE, _errorMessage.ErrorMessage.ScalarExpected);
            } else {
              return wrapperUnary(this.arithmeticHelper.unaryPercent, this.arithmeticHelper.coerceScalarToNumberOrError(_result2));
            }
          }

        case _Ast.AstNodeType.FUNCTION_CALL:
          {
            if (this.config.licenseKeyValidityState !== "valid"
            /* VALID */
            && !_FunctionRegistry.FunctionRegistry.functionIsProtected(ast.procedureName)) {
              return new _Cell.CellError(_Cell.ErrorType.LIC, _errorMessage.ErrorMessage.LicenseKey(this.config.licenseKeyValidityState));
            }

            var pluginEntry = this.functionRegistry.getFunction(ast.procedureName);

            if (pluginEntry && this.config.translationPackage.isFunctionTranslated(ast.procedureName)) {
              var _pluginEntry = _slicedToArray(pluginEntry, 2),
                  pluginFunction = _pluginEntry[0],
                  pluginInstance = _pluginEntry[1];

              return pluginInstance[pluginFunction](ast, formulaAddress);
            } else {
              return new _Cell.CellError(_Cell.ErrorType.NAME, _errorMessage.ErrorMessage.FunctionName(ast.procedureName));
            }
          }

        case _Ast.AstNodeType.NAMED_EXPRESSION:
          {
            var namedExpression = this.namedExpressions.nearestNamedExpression(ast.expressionName, formulaAddress.sheet);

            if (namedExpression) {
              return this.dependencyGraph.getCellValue(namedExpression.address);
            } else {
              return new _Cell.CellError(_Cell.ErrorType.NAME, _errorMessage.ErrorMessage.NamedExpressionName(ast.expressionName));
            }
          }

        case _Ast.AstNodeType.CELL_RANGE:
          {
            if (!this.rangeSpansOneSheet(ast)) {
              return new _Cell.CellError(_Cell.ErrorType.REF, _errorMessage.ErrorMessage.RangeManySheets);
            }

            var range = _AbsoluteCellRange.AbsoluteCellRange.fromCellRange(ast, formulaAddress);

            var matrixVertex = this.dependencyGraph.getMatrix(range);

            if (matrixVertex) {
              var matrix = matrixVertex.matrix;

              if (matrix instanceof _Matrix.NotComputedMatrix) {
                throw new Error('Matrix should be already computed');
              } else if (matrix instanceof _Cell.CellError) {
                return matrix;
              } else if (matrix instanceof _Matrix.Matrix) {
                return _SimpleRangeValue.SimpleRangeValue.onlyNumbersDataWithRange(matrix.raw(), matrix.size, range);
              } else {
                throw new Error('Unknown matrix');
              }
            } else {
              return _SimpleRangeValue.SimpleRangeValue.onlyRange(range, this.dependencyGraph);
            }
          }

        case _Ast.AstNodeType.COLUMN_RANGE:
          {
            if (!this.rangeSpansOneSheet(ast)) {
              return new _Cell.CellError(_Cell.ErrorType.REF, _errorMessage.ErrorMessage.RangeManySheets);
            }

            var _range = _AbsoluteCellRange.AbsoluteColumnRange.fromColumnRange(ast, formulaAddress);

            return _SimpleRangeValue.SimpleRangeValue.onlyRange(_range, this.dependencyGraph);
          }

        case _Ast.AstNodeType.ROW_RANGE:
          {
            if (!this.rangeSpansOneSheet(ast)) {
              return new _Cell.CellError(_Cell.ErrorType.REF, _errorMessage.ErrorMessage.RangeManySheets);
            }

            var _range2 = _AbsoluteCellRange.AbsoluteRowRange.fromRowRange(ast, formulaAddress);

            return _SimpleRangeValue.SimpleRangeValue.onlyRange(_range2, this.dependencyGraph);
          }

        case _Ast.AstNodeType.PARENTHESIS:
          {
            return this.evaluateAst(ast.expression, formulaAddress);
          }

        case _Ast.AstNodeType.ERROR_WITH_RAW_INPUT:
        case _Ast.AstNodeType.ERROR:
          {
            return ast.error;
          }
      }
    }
  }, {
    key: "getGpuInstance",
    value: function getGpuInstance() {
      var mode = this.config.gpuMode;
      var gpujs = this.config.gpujs;

      if (gpujs === undefined) {
        throw Error('Cannot instantiate GPU.js. Constructor not provided.');
      }

      if (!this.gpu) {
        this.gpu = new gpujs({
          mode: mode
        });
      }

      return this.gpu;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.gpu) {
        this.gpu.destroy();
      }
    }
  }, {
    key: "rangeSpansOneSheet",
    value: function rangeSpansOneSheet(ast) {
      return ast.start.sheet === ast.end.sheet;
    }
  }]);

  return Interpreter;
}();

exports.Interpreter = Interpreter;

function passErrors(left, right) {
  if (left instanceof _Cell.CellError) {
    return left;
  } else if (left instanceof _SimpleRangeValue.SimpleRangeValue) {
    return new _Cell.CellError(_Cell.ErrorType.VALUE, _errorMessage.ErrorMessage.ScalarExpected);
  } else if (right instanceof _Cell.CellError) {
    return right;
  } else if (right instanceof _SimpleRangeValue.SimpleRangeValue) {
    return new _Cell.CellError(_Cell.ErrorType.VALUE, _errorMessage.ErrorMessage.ScalarExpected);
  } else {
    return undefined;
  }
}

function wrapperUnary(op, a) {
  if (a instanceof _Cell.CellError) {
    return a;
  } else {
    return op(a);
  }
}

function wrapperBinary(op, a, b) {
  if (a instanceof _Cell.CellError) {
    return a;
  } else if (b instanceof _Cell.CellError) {
    return b;
  } else {
    return op(a, b);
  }
}

function wrapperForAddress(val, adr) {
  if (val instanceof _Cell.CellError) {
    return val.attachAddress(adr);
  }

  return val;
}